<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <link href="http://gmpg.org/xfn/11" rel="profile">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
    
      There's Always More to Learn &middot; finleye
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/styles.css">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/public/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/public/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/atom+xml" title="finleye" href="/atom.xml">
</head>


  <body>

    <div class="container content">
      <header class="masthead">
        <a href="/about">
          <img src="/assets/images/prof-pic-a.jpg" class="avatar" align="left" />
        </a>
        <h3 class="masthead-title">
          <a href="/" title="Home">finleye</a>
          <small>Ruby on Rails Dev</small>
        </h3>
      </header>

      <main>
        <article class="post">
  <h1 class="post-title">There's Always More to Learn</h1>
  <time datetime="2016-01-16T09:00:00-05:00" class="post-date">16 Jan 2016</time>
  <p>I’ve been trying to broaden my skill set lately. I’m reading books that I should have long before now (<a href="http://www.amazon.com/Practical-Object-Oriented-Design-Ruby-Addison-Wesley/dp/0321721330">Practical Object-Oriented Design in Ruby</a>, and <a href="http://www.amazon.com/The-Pragmatic-Programmer-Journeyman-Master/dp/020161622X">The Pragmatic Programmer</a>), and I’m trying out a few languages. I wanted to play with functional programming because I have very little exposure to it, so on the suggestion of a co-worker, I started reading through <a href="http://www.amazon.com/The-Little-Schemer-4th-Edition/dp/0262560992">The Little Schemer</a>. It made me think about problems in a new way, and I think it improved my daily work.</p>

<h4 id="a-little-schemen">A little Scheme’n</h4>

<p>In a technical interview I was asked to write out, on a white board, how to implement <a href="http://apidock.com/ruby/Array/flatten">Ruby’s <code class="highlighter-rouge">flatten</code> method</a>. Flatten takes an Array and reduces it to a single dimension. I think this is a great exercise when trying out new languages, because you get to interact with objects, dissect them, and reconstruct them.</p>

<p><a href="http://www.amazon.com/The-Little-Schemer-4th-Edition/dp/0262560992">The Little Schemer</a> impresses that when working with functional languages you need to set out rules about how the iterations should work. Here’s the list for my algorithm:</p>

<ol>
  <li>Return when: all elements are <code class="highlighter-rouge">atom</code>s.</li>
  <li>Handle nulls: if the tail is null, then the only element is the head, flatten it!</li>
  <li>Else: merge the flattened head, and the flattened tail.</li>
</ol>

<p>First, let’s write a small test so that we know when it works.</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="c1">; sample lists</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">l</span> <span class="o">'</span><span class="p">((</span><span class="nf">a</span><span class="p">)</span> <span class="nv">b</span><span class="p">)</span> <span class="p">)</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">m</span> <span class="o">'</span><span class="p">(((</span><span class="nf">a</span><span class="p">))</span> <span class="p">(</span><span class="nf">b</span><span class="p">))</span> <span class="p">)</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">n</span> <span class="o">'</span><span class="p">((</span><span class="nf">a</span> <span class="nv">b</span><span class="p">)</span> <span class="p">(</span><span class="nf">c</span> <span class="p">(</span><span class="nf">d</span> <span class="nv">e</span><span class="p">))))</span>

<span class="c1">; test flatten against all sample lists</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">spec</span>
    <span class="p">(</span><span class="k">and</span>
        <span class="p">(</span><span class="nf">all_atoms?</span> <span class="p">(</span><span class="nf">flatten</span> <span class="nv">l</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">all_atoms?</span> <span class="p">(</span><span class="nf">flatten</span> <span class="nv">m</span><span class="p">))</span>
        <span class="p">(</span><span class="nf">all_atoms?</span> <span class="p">(</span><span class="nf">flatten</span> <span class="nv">n</span><span class="p">))</span>
    <span class="p">)</span>
<span class="p">)</span></code></pre></figure>

<p>Run it:</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="nv">Error:</span> <span class="nv">execute:</span> <span class="nv">unbound</span> <span class="nv">symbol:</span> <span class="s">"flatten"</span> <span class="err">[]</span></code></pre></figure>

<p>Nice, let’s get started. Is the list <code class="highlighter-rouge">all_atoms?</code></p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="k">define</span> <span class="nv">atom?</span>
    <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span>
        <span class="p">(</span><span class="k">and</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">pair?</span> <span class="nv">x</span><span class="p">))</span> <span class="p">(</span><span class="nb">not</span> <span class="p">(</span><span class="nb">null?</span> <span class="nv">x</span><span class="p">)))))</span>

<span class="p">(</span><span class="k">define</span> <span class="nv">all_atoms?</span>
    <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">li</span><span class="p">)</span>
        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null?</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">li</span><span class="p">))</span>
            <span class="p">(</span><span class="nf">atom?</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">li</span><span class="p">))</span>
            <span class="p">(</span><span class="k">and</span> <span class="p">(</span><span class="nf">atom?</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">li</span><span class="p">))</span> <span class="p">(</span><span class="nf">all_atoms?</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">li</span><span class="p">))))))</span></code></pre></figure>

<p>Eight lines, and forty two parenthesis later, we have a method that checks each element to see if it’s an <code class="highlighter-rouge">atom</code> only returning false if it’s not. We also have to merge the lists, so let’s write the <code class="highlighter-rouge">merge</code> method.</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="k">define</span> <span class="p">(</span><span class="nf">merge</span> <span class="nv">l1</span> <span class="nv">l2</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null?</span> <span class="nv">l1</span><span class="p">)</span> <span class="nv">l2</span>
        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null?</span> <span class="nv">l2</span><span class="p">)</span> <span class="nv">l1</span>
            <span class="p">(</span><span class="nb">cons</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">l1</span><span class="p">)</span> <span class="p">(</span><span class="nf">merge</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">l1</span><span class="p">)</span> <span class="nv">l2</span><span class="p">)))))</span></code></pre></figure>

<p>Also recursive, this method takes each element and adds it to the larger list.</p>

<p>Finally flatten them!</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="p">(</span><span class="k">define</span> <span class="nv">flatten</span>
    <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span>
        <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nf">all_atoms?</span> <span class="nv">x</span><span class="p">)</span> <span class="nv">x</span>
            <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">null?</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">))</span> <span class="p">(</span><span class="nf">flatten</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">))</span>
                <span class="p">(</span><span class="nf">merge</span> <span class="p">(</span><span class="nf">flatten</span> <span class="p">(</span><span class="nb">list</span> <span class="p">(</span><span class="nb">car</span> <span class="nv">x</span><span class="p">)))</span> <span class="p">(</span><span class="nf">flatten</span> <span class="p">(</span><span class="nb">cdr</span> <span class="nv">x</span><span class="p">)))))))</span></code></pre></figure>

<p>Here we first check that the list is not all atoms, if it is, return it. If it has a list inside, continue. If the tail is null, then it’s just the head and it’s not an <code class="highlighter-rouge">atom</code> so flatten it. And finally if there is a head and a tail, merge the flattened version of the two.</p>

<p>Let’s run it and see if it works.</p>

<figure class="highlight"><pre><code class="language-scheme" data-lang="scheme"><span class="nv">:&gt;</span> <span class="nv">spec</span>
<span class="nv">=&gt;</span> <span class="no">#t</span></code></pre></figure>

<p>Boom! My obviously perfect test show how incredible my code is! Of course I’m kidding, but this looks like it is in fact working. You can take my word for it, or check out this <a href="https://repl.it/BQKT/12">repl.it</a> link to give it a shot. Now that it’s working, I want to try another language.</p>

<h4 id="elixir">Elixir</h4>

<p>Some people in my office have been talking about <a href="http://elixir-lang.org/">Elixir</a>, and I wanted to try it out, so I thought this was another perfect time to try to write flatten. I downloaded the language, and kicked up a new project with <code class="highlighter-rouge">mix</code>.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">mix new flatten</code></pre></figure>

<p>Let’s write some tests</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="c1"># test/flatten_test.exs</span>
<span class="k">defmodule</span> <span class="no">FlattenTest</span> <span class="k">do</span>
  <span class="kn">use</span> <span class="no">ExUnit</span><span class="o">.</span><span class="no">Case</span>
  <span class="n">doctest</span> <span class="no">Flatten</span>

  <span class="n">test</span> <span class="sd">"</span><span class="s2">empty list"</span> <span class="k">do</span>
    <span class="n">assert</span> <span class="no">Flatten</span><span class="o">.</span><span class="n">flatten</span><span class="p">([])</span> <span class="o">==</span> <span class="p">[]</span>
  <span class="k">end</span>

  <span class="n">test</span> <span class="sd">"</span><span class="s2">list of atoms"</span> <span class="k">do</span>
    <span class="n">assert</span> <span class="no">Flatten</span><span class="o">.</span><span class="n">flatten</span><span class="p">([</span><span class="ss">:a</span><span class="p">,</span> <span class="ss">:b</span><span class="p">,</span> <span class="ss">:c</span><span class="p">])</span> <span class="o">==</span> <span class="p">[</span><span class="ss">:a</span><span class="p">,</span> <span class="ss">:b</span><span class="p">,</span> <span class="ss">:c</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="n">test</span> <span class="sd">"</span><span class="s2">list of mixed data types"</span> <span class="k">do</span>
    <span class="n">assert</span> <span class="no">Flatten</span><span class="o">.</span><span class="n">flatten</span><span class="p">([</span><span class="ss">:a</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="ss">:c</span><span class="p">])</span> <span class="o">==</span> <span class="p">[</span><span class="ss">:a</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="ss">:c</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="n">test</span> <span class="sd">"</span><span class="s2">flattens a list of an empty list"</span> <span class="k">do</span>
    <span class="n">assert</span> <span class="no">Flatten</span><span class="o">.</span><span class="n">flatten</span><span class="p">([[]])</span> <span class="o">==</span> <span class="p">[]</span>
  <span class="k">end</span>

  <span class="n">test</span> <span class="sd">"</span><span class="s2">flattens a list within a list"</span> <span class="k">do</span>
    <span class="n">assert</span> <span class="no">Flatten</span><span class="o">.</span><span class="n">flatten</span><span class="p">([</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="p">[</span><span class="m">3</span><span class="p">]])</span> <span class="o">==</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="n">test</span> <span class="sd">"</span><span class="s2">flattens a list within a list, when the head is a list"</span> <span class="k">do</span>
    <span class="n">assert</span> <span class="no">Flatten</span><span class="o">.</span><span class="n">flatten</span><span class="p">([[</span><span class="m">1</span><span class="p">],</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">])</span> <span class="o">==</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="n">test</span> <span class="sd">"</span><span class="s2">flattens a list within a list, when the head is a list in a list"</span> <span class="k">do</span>
    <span class="n">assert</span> <span class="no">Flatten</span><span class="o">.</span><span class="n">flatten</span><span class="p">([[[</span><span class="m">1</span><span class="p">]],</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">])</span> <span class="o">==</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">]</span>
  <span class="k">end</span>

  <span class="n">test</span> <span class="sd">"</span><span class="s2">flattens a list within a list, when the tail is a multipart list"</span> <span class="k">do</span>
    <span class="n">assert</span> <span class="no">Flatten</span><span class="o">.</span><span class="n">flatten</span><span class="p">([</span><span class="m">1</span><span class="p">,</span> <span class="p">[</span><span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">]])</span> <span class="o">==</span> <span class="p">[</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span></code></pre></figure>

<p>Run it</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>mix <span class="nb">test
</span>8 tests, 8 failures</code></pre></figure>

<p>Cool! Got some tests. Let’s get started.</p>

<p>First, we need a handler method, we’ll just call it <code class="highlighter-rouge">flatten</code>, the first handler will just handle the empty array case.</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="k">def</span> <span class="n">flatten</span><span class="p">(</span><span class="n">input</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">_flatten</span><span class="p">(</span><span class="n">input</span><span class="p">)</span>
<span class="k">defp</span> <span class="n">_flatten</span><span class="p">([]),</span> <span class="k">do</span><span class="p">:</span> <span class="p">[]</span></code></pre></figure>

<p>Now if we run the test again, we should at least get the first one to pass.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>mix <span class="nb">test
</span>8 tests, 7 failures</code></pre></figure>

<p>Nice. One down and only seven to go. Now there are two cases for the iteration. The head is a list, in which case we should concatenate the flattened head with the flattened tail.</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="k">defp</span> <span class="n">_flatten</span><span class="p">([</span><span class="n">head</span><span class="o">|</span><span class="n">tail</span><span class="p">])</span> <span class="ow">when</span> <span class="n">is_list</span><span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">_flatten</span><span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="o">++</span> <span class="n">_flatten</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>
<span class="k">end</span></code></pre></figure>

<p>That gets us down to just six failures, so let’s handle the other case. If the head is not a list, we should concatenate the head in a list, with the flattened version of the tail. That looks like this;</p>

<figure class="highlight"><pre><code class="language-elixir" data-lang="elixir"><span class="k">defp</span> <span class="n">_flatten</span><span class="p">([</span><span class="n">head</span><span class="o">|</span><span class="n">tail</span><span class="p">]),</span> <span class="k">do</span><span class="p">:</span> <span class="p">[</span><span class="n">head</span><span class="p">]</span> <span class="o">++</span> <span class="n">_flatten</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span></code></pre></figure>

<p>You can see the <a href="https://github.com/finleye/flatten/blob/master/lib/flatten.ex">full Flatten module here</a>. Let’s try it!</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>mix <span class="nb">test
</span>8 tests, 0 failures</code></pre></figure>

<p>Nice! All green! As you can see I’ve barely scratched the surface of what this language is capable of, but at least I’ve figured out some of the syntax and how the language works. If you want to see the full <code class="highlighter-rouge">mix</code> project, it’s <a href="https://github.com/finleye/flatten">here in a repo</a>.</p>

<h4 id="onward-and-upward">Onward and upward</h4>

<p>I really liked working with these other languages, and plan to spend more time with them. I don’t often use recursion as a strategy for solving problems in my daily work, it rarely calls for it. But these exercises make me think about programming challenges in a different way, and that’s always a good thing.</p>

<p>I’m still working on my next post about my Sinatra project. But I’ll have it posted shortly. As always, feel free to contact me on <a href="https://twitter.com/cfinley">twitter</a> or <a href="&#109;&#097;&#105;&#108;&#116;&#111;:&#102;&#105;&#110;&#108;&#101;&#121;&#046;&#099;&#111;&#114;&#101;&#121;&#064;&#103;&#109;&#097;&#105;&#108;&#046;&#099;&#111;&#109;">email</a> me. See you soon! See you soon!</p>


</article>


<aside class="related">
  <h2>Related Posts</h2>
  <ul class="related-posts">
    
      <li>
        <h3>
          <a href="/sinatra/2016/01/19/haml-and-partials.html">
            HAML and Partials
            <small><time datetime="2016-01-19T09:00:00-05:00">19 Jan 2016</time></small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/instagram/sandbox/2016/01/15/sandbox-mode.html">
            Head in the Sandbox
            <small><time datetime="2016-01-15T09:00:00-05:00">15 Jan 2016</time></small>
          </a>
        </h3>
      </li>
    
      <li>
        <h3>
          <a href="/sinatra/instagram/2016/01/14/instagram-integration.html">
            Instagram Integration
            <small><time datetime="2016-01-14T09:00:00-05:00">14 Jan 2016</time></small>
          </a>
        </h3>
      </li>
    
  </ul>
</aside>


      </main>

      <footer class="footer">
  <div>
    <a href="/about">About me</a>
    <a href="https://github.com/finleye"><span class="icon icon--github"><svg viewBox="0 0 16 16"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/></svg>
</span><span class="username">finleye</span></a>

    <a href="https://twitter.com/cfinley"><span class="icon icon--twitter"><svg viewBox="0 0 16 16"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/></svg>
</span><span class="username">cfinley</span></a>

  </div>
  <small>
    &copy; <time datetime="2016-01-19T20:41:31-05:00">2016</time>. All rights reserved.
  </small>
  <small>
    <a href="/disclaimer">Disclaimer</a>
  </small>
</footer>

      <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42037834-2', 'auto');
  ga('send', 'pageview');

</script>

    </div>
  </body>
</html>
